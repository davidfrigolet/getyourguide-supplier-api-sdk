<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace Gyg\Thrift\Service\SupplierApi;


interface NotificationServiceIf {
    /**
     * Original thrift definition:-
     * void
     *   notifyAvailabilityUpdate(1: string productId,
     *                            2: string fromDateTime,
     *                            3: string toDateTime)
     *   throws (1: InvalidProductException invalidProductException,
     *           2: ValidationException validationException,
     *           3: AuthorizationException authorizationException,
     *           4: InternalSystemException internalSystemException);
     */
    public function notifyAvailabilityUpdate($productId, $fromDateTime, $toDateTime);
}

class NotificationServiceClient implements NotificationServiceIf, \IThriftClient {
    protected $input_ = null;
    protected $output_ = null;

    protected $seqid_ = 0;

    public function __construct(\TProtocol $input, /*?\TProtocol*/ $output=null) {
      $this->input_ = $input;
      $this->output_ = $output ? $output : $input;
      $this->eventHandler_ = new \TClientEventHandler();
    }

    public function setEventHandler(\TClientEventHandler $event_handler) {
      $this->eventHandler_ = $event_handler;
    }

    public function getEventHandler() {
      return $this->eventHandler_;
    }

    private function getsequenceid() {
      $currentseqid = $this->seqid_;
      if ($this->seqid_ >= 0x7fffffff) {
         $this->seqid_ = 0;
      } else {
         $this->seqid_++;
      }
      return $currentseqid;
    }

    /**
     * Original thrift definition:-
     * void
     *   notifyAvailabilityUpdate(1: string productId,
     *                            2: string fromDateTime,
     *                            3: string toDateTime)
     *   throws (1: InvalidProductException invalidProductException,
     *           2: ValidationException validationException,
     *           3: AuthorizationException authorizationException,
     *           4: InternalSystemException internalSystemException);
     */
    public function notifyAvailabilityUpdate($productId, $fromDateTime, $toDateTime)
    {
      $currentseqid = $this->send_notifyAvailabilityUpdate($productId, $fromDateTime, $toDateTime);
      $this->recv_notifyAvailabilityUpdate($currentseqid);
    }

    public function send_notifyAvailabilityUpdate($productId, $fromDateTime, $toDateTime)
    {
      $currentseqid = $this->getsequenceid();
      $args = new NotificationService_notifyAvailabilityUpdate_args();
      $args->productId = $productId;
      $args->fromDateTime = $fromDateTime;
      $args->toDateTime = $toDateTime;
      try {
        $this->eventHandler_->preSend('notifyAvailabilityUpdate', $args, $currentseqid);
        $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
        $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
        if ($bin_accel)
        {
          thrift_protocol_write_binary($this->output_, 'notifyAvailabilityUpdate', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
        }
        else if ($compact_accel)
        {
          thrift_protocol_write_compact($this->output_, 'notifyAvailabilityUpdate', \TMessageType::CALL, $args, $currentseqid, false);
        }
        else
        {
          $this->output_->writeMessageBegin('notifyAvailabilityUpdate', \TMessageType::CALL, $currentseqid);
          $args->write($this->output_);
          $this->output_->writeMessageEnd();
          $this->output_->getTransport()->flush();
        }
      } catch (\THandlerShortCircuitException $ex) {
        switch ($ex->resultType) {
          case \THandlerShortCircuitException::R_EXPECTED_EX:
          case \THandlerShortCircuitException::R_UNEXPECTED_EX:
            $this->eventHandler_->sendError('notifyAvailabilityUpdate', $args, $currentseqid, $ex->result);
            throw $ex->result;
          case \THandlerShortCircuitException::R_SUCCESS:
          default:
            $this->eventHandler_->postSend('notifyAvailabilityUpdate', $args, $currentseqid);
            return $currentseqid;
        }
      } catch (\Exception $ex) {
        $this->eventHandler_->sendError('notifyAvailabilityUpdate', $args, $currentseqid, $ex);
        throw $ex;
      }
      $this->eventHandler_->postSend('notifyAvailabilityUpdate', $args, $currentseqid);
      return $currentseqid;
    }

    public function recv_notifyAvailabilityUpdate($expectedsequenceid = null)
    {
      try {
        $this->eventHandler_->preRecv('notifyAvailabilityUpdate', $expectedsequenceid);
        $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
        $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
        if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'NotificationService_notifyAvailabilityUpdate_result', $this->input_->isStrictRead());
        else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'NotificationService_notifyAvailabilityUpdate_result');
        else
        {
          $rseqid = 0;
          $fname = null;
          $mtype = 0;

          $this->input_->readMessageBegin($fname, $mtype, $rseqid);
          if ($mtype == \TMessageType::EXCEPTION) {
            $x = new \TApplicationException();
            $x->read($this->input_);
            $this->input_->readMessageEnd();
            throw $x;
          }
          $result = new NotificationService_notifyAvailabilityUpdate_result();
          $result->read($this->input_);
          $this->input_->readMessageEnd();
          if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
            throw new \TProtocolException("notifyAvailabilityUpdate failed: sequence id is out of order");
          }
        }
      } catch (\THandlerShortCircuitException $ex) {
        switch ($ex->resultType) {
          case \THandlerShortCircuitException::R_EXPECTED_EX:
            $this->eventHandler_->recvException('notifyAvailabilityUpdate', $expectedsequenceid, $ex->result);
            throw $ex->result;
          case \THandlerShortCircuitException::R_UNEXPECTED_EX:
            $this->eventHandler_->recvError('notifyAvailabilityUpdate', $expectedsequenceid, $ex->result);
            throw $ex->result;
          case \THandlerShortCircuitException::R_SUCCESS:
          default:
            $this->eventHandler_->postRecv('notifyAvailabilityUpdate', $expectedsequenceid, $ex->result);
            return $ex->result;
        }
      } catch (\Exception $ex) {
        $this->eventHandler_->recvError('notifyAvailabilityUpdate', $expectedsequenceid, $ex);
        throw $ex;
      }
      if ($result->invalidProductException !== null) {
        $this->eventHandler_->recvException('notifyAvailabilityUpdate', $expectedsequenceid, $result->invalidProductException);
        throw $result->invalidProductException;
      }
      if ($result->validationException !== null) {
        $this->eventHandler_->recvException('notifyAvailabilityUpdate', $expectedsequenceid, $result->validationException);
        throw $result->validationException;
      }
      if ($result->authorizationException !== null) {
        $this->eventHandler_->recvException('notifyAvailabilityUpdate', $expectedsequenceid, $result->authorizationException);
        throw $result->authorizationException;
      }
      if ($result->internalSystemException !== null) {
        $this->eventHandler_->recvException('notifyAvailabilityUpdate', $expectedsequenceid, $result->internalSystemException);
        throw $result->internalSystemException;
      }
      $this->eventHandler_->postRecv('notifyAvailabilityUpdate', $expectedsequenceid, null);
      return;
    }

}

class NotificationServiceProcessor implements \IThriftProcessor {
    protected $handler_ = null;
    protected $eventHandler_ = null;
    protected $exceptionHandler_ = null;
    public function __construct(NotificationServiceIf $handler) {
      $this->handler_ = $handler;
      $this->eventHandler_ = new \TProcessorEventHandler();
    }

    public function setEventHandler(\TProcessorEventHandler $event_handler) {
      $this->eventHandler_ = $event_handler;
    }

    public function getEventHandler() {
      return $this->eventHandler_;
    }

    public function setExceptionHandler(\IProcessorExceptionHandler $exception_handler) {
      $this->exceptionHandler_ = $exception_handler;
    }

    public function getExceptionHandler() {
      return $this->exceptionHandler_;
    }

    public function process(\TProtocol $input, \TProtocol $output) {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $input->readMessageBegin($fname, $mtype, $rseqid);
      $methodname = 'process_'.$fname;
      if (!method_exists($this, $methodname)) {
        $handler_ctx = $this->eventHandler_->getHandlerContext($methodname);
        $this->eventHandler_->preRead($handler_ctx, $methodname, array());
        $input->skip(\TType::STRUCT);
        $input->readMessageEnd();
        $this->eventHandler_->postRead($handler_ctx, $methodname, array());
        $x = new \TApplicationException('Function '.$fname.' not implemented.', \TApplicationException::UNKNOWN_METHOD);
        $this->eventHandler_->handlerError($handler_ctx, $methodname, $x);
        $output->writeMessageBegin($fname, \TMessageType::EXCEPTION, $rseqid);
        $x->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        return;
      }
      $this->$methodname($rseqid, $input, $output);
      return true;
    }

    protected function process_notifyAvailabilityUpdate($seqid, \TProtocol $input, \TProtocol $output) {
      $handler_ctx = $this->eventHandler_->getHandlerContext('notifyAvailabilityUpdate');
      $reply_type = \TMessageType::REPLY;

      $this->eventHandler_->preRead($handler_ctx, 'notifyAvailabilityUpdate', array());

      $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
      $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

      if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'NotificationService_notifyAvailabilityUpdate_args');
      else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'NotificationService_notifyAvailabilityUpdate_args');
      else {
        $args = new NotificationService_notifyAvailabilityUpdate_args();
        $args->read($input);
      }
      $input->readMessageEnd();
      $this->eventHandler_->postRead($handler_ctx, 'notifyAvailabilityUpdate', $args);
      $result = new NotificationService_notifyAvailabilityUpdate_result();
      try {
        $this->eventHandler_->preExec($handler_ctx, 'notifyAvailabilityUpdate', $args);
        try {
          $this->handler_->notifyAvailabilityUpdate($args->productId, $args->fromDateTime, $args->toDateTime);
        } catch (\Exception $e) {
          if ($this->exceptionHandler_ === null) {
            throw  $e;
          } else {
            $this->exceptionHandler_->handle('notifyAvailabilityUpdate', $e);
          }
        }
        $this->eventHandler_->postExec($handler_ctx, 'notifyAvailabilityUpdate', $result);
      } catch (InvalidProductException $exc0) {
        $this->eventHandler_->handlerException($handler_ctx, 'notifyAvailabilityUpdate', $exc0);
        $result->invalidProductException = $exc0;
      } catch (ValidationException $exc1) {
        $this->eventHandler_->handlerException($handler_ctx, 'notifyAvailabilityUpdate', $exc1);
        $result->validationException = $exc1;
      } catch (AuthorizationException $exc2) {
        $this->eventHandler_->handlerException($handler_ctx, 'notifyAvailabilityUpdate', $exc2);
        $result->authorizationException = $exc2;
      } catch (InternalSystemException $exc3) {
        $this->eventHandler_->handlerException($handler_ctx, 'notifyAvailabilityUpdate', $exc3);
        $result->internalSystemException = $exc3;
      } catch (\Exception $ex) {
        $reply_type = \TMessageType::EXCEPTION;
        $this->eventHandler_->handlerError($handler_ctx, 'notifyAvailabilityUpdate', $ex);
        $result = new \TApplicationException($ex->getMessage());
      }
      $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
      $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      $this->eventHandler_->preWrite($handler_ctx, 'notifyAvailabilityUpdate', $result);
      if ($bin_accel)
      {
        thrift_protocol_write_binary($output, 'notifyAvailabilityUpdate', $reply_type, $result, $seqid, $output->isStrictWrite());
      }
      else if ($compact_accel)
      {
        thrift_protocol_write_compact($output, 'notifyAvailabilityUpdate', $reply_type, $result, $seqid);
      }
      else
      {
        $output->writeMessageBegin("notifyAvailabilityUpdate", $reply_type, $seqid);
        $result->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
      }
      $this->eventHandler_->postWrite($handler_ctx, 'notifyAvailabilityUpdate', $result);
    }
}
// HELPER FUNCTIONS AND STRUCTURES

class NotificationService_notifyAvailabilityUpdate_args implements \IThriftStruct {
      static $_TSPEC = array(
        1 => array(
          'var' => 'productId',
          'type' => \TType::STRING,
          ),
        2 => array(
          'var' => 'fromDateTime',
          'type' => \TType::STRING,
          ),
        3 => array(
          'var' => 'toDateTime',
          'type' => \TType::STRING,
          ),
        );
      public static $_TFIELDMAP = array(
        'productId' => 1,
        'fromDateTime' => 2,
        'toDateTime' => 3,
      );
      const STRUCTURAL_ID = 2810007422305526495;
      public $productId = null;
      public $fromDateTime = null;
      public $toDateTime = null;

      public function __construct($vals=null) {
        if (is_array($vals)) {
          if (isset($vals['productId'])) {
            $this->productId = $vals['productId'];
          }
          if (isset($vals['fromDateTime'])) {
            $this->fromDateTime = $vals['fromDateTime'];
          }
          if (isset($vals['toDateTime'])) {
            $this->toDateTime = $vals['toDateTime'];
          }
        } else if ($vals) {
          throw new \TProtocolException(
            'NotificationService_notifyAvailabilityUpdate_args constructor must be passed array or null'
          );
        }
      }

      public function getName() {
        return 'NotificationService_notifyAvailabilityUpdate_args';
      }

      public static function __set_state($vals) {
        return new NotificationService_notifyAvailabilityUpdate_args($vals);
      }

      public function read(\TProtocol $input)
      {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true)
        {
          $xfer += $input->readFieldBegin($fname, $ftype, $fid);
          if ($ftype == \TType::STOP) {
            break;
          }
          if (!$fid && $fname !== null) {
            if (isset(self::$_TFIELDMAP[$fname])) {
              $fid = self::$_TFIELDMAP[$fname];
              $ftype = self::$_TSPEC[$fid]['type'];
            }
          }
          switch ($fid)
          {
            case 1:
              if ($ftype == \TType::STRING) {
                $xfer += $input->readString($this->productId);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            case 2:
              if ($ftype == \TType::STRING) {
                $xfer += $input->readString($this->fromDateTime);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            case 3:
              if ($ftype == \TType::STRING) {
                $xfer += $input->readString($this->toDateTime);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            default:
              $xfer += $input->skip($ftype);
              break;
          }
          $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
      }

      public function write(\TProtocol $output) {
        $xfer = 0;
        $xfer += $output->writeStructBegin('NotificationService_notifyAvailabilityUpdate_args');
        if ($this->productId !== null) {
          $xfer += $output->writeFieldBegin('productId', \TType::STRING, 1);
          $xfer += $output->writeString($this->productId);
          $xfer += $output->writeFieldEnd();
        }
        if ($this->fromDateTime !== null) {
          $xfer += $output->writeFieldBegin('fromDateTime', \TType::STRING, 2);
          $xfer += $output->writeString($this->fromDateTime);
          $xfer += $output->writeFieldEnd();
        }
        if ($this->toDateTime !== null) {
          $xfer += $output->writeFieldBegin('toDateTime', \TType::STRING, 3);
          $xfer += $output->writeString($this->toDateTime);
          $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
      }

    }

class NotificationService_notifyAvailabilityUpdate_result implements \IThriftStruct {
      static $_TSPEC = array(
        1 => array(
          'var' => 'invalidProductException',
          'type' => \TType::STRUCT,
          'class' => 'InvalidProductException',
          ),
        2 => array(
          'var' => 'validationException',
          'type' => \TType::STRUCT,
          'class' => 'ValidationException',
          ),
        3 => array(
          'var' => 'authorizationException',
          'type' => \TType::STRUCT,
          'class' => 'AuthorizationException',
          ),
        4 => array(
          'var' => 'internalSystemException',
          'type' => \TType::STRUCT,
          'class' => 'InternalSystemException',
          ),
        );
      public static $_TFIELDMAP = array(
        'invalidProductException' => 1,
        'validationException' => 2,
        'authorizationException' => 3,
        'internalSystemException' => 4,
      );
      const STRUCTURAL_ID = 3439844031683737646;
      public $invalidProductException = null;
      public $validationException = null;
      public $authorizationException = null;
      public $internalSystemException = null;

      public function __construct($vals=null) {
        if (is_array($vals)) {
          if (isset($vals['invalidProductException'])) {
            $this->invalidProductException = $vals['invalidProductException'];
          }
          if (isset($vals['validationException'])) {
            $this->validationException = $vals['validationException'];
          }
          if (isset($vals['authorizationException'])) {
            $this->authorizationException = $vals['authorizationException'];
          }
          if (isset($vals['internalSystemException'])) {
            $this->internalSystemException = $vals['internalSystemException'];
          }
        } else if ($vals) {
          throw new \TProtocolException(
            'NotificationService_notifyAvailabilityUpdate_result constructor must be passed array or null'
          );
        }
      }

      public function getName() {
        return 'NotificationService_notifyAvailabilityUpdate_result';
      }

      public static function __set_state($vals) {
        return new NotificationService_notifyAvailabilityUpdate_result($vals);
      }

      public function read(\TProtocol $input)
      {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true)
        {
          $xfer += $input->readFieldBegin($fname, $ftype, $fid);
          if ($ftype == \TType::STOP) {
            break;
          }
          if (!$fid && $fname !== null) {
            if (isset(self::$_TFIELDMAP[$fname])) {
              $fid = self::$_TFIELDMAP[$fname];
              $ftype = self::$_TSPEC[$fid]['type'];
            }
          }
          switch ($fid)
          {
            case 1:
              if ($ftype == \TType::STRUCT) {
                $this->invalidProductException = new InvalidProductException();
                $xfer += $this->invalidProductException->read($input);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            case 2:
              if ($ftype == \TType::STRUCT) {
                $this->validationException = new ValidationException();
                $xfer += $this->validationException->read($input);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            case 3:
              if ($ftype == \TType::STRUCT) {
                $this->authorizationException = new AuthorizationException();
                $xfer += $this->authorizationException->read($input);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            case 4:
              if ($ftype == \TType::STRUCT) {
                $this->internalSystemException = new InternalSystemException();
                $xfer += $this->internalSystemException->read($input);
              } else {
                $xfer += $input->skip($ftype);
              }
              break;
            default:
              $xfer += $input->skip($ftype);
              break;
          }
          $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
      }

      public function write(\TProtocol $output) {
        $xfer = 0;
        $xfer += $output->writeStructBegin('NotificationService_notifyAvailabilityUpdate_result');
        if ($this->invalidProductException !== null) {
          $xfer += $output->writeFieldBegin('invalidProductException', \TType::STRUCT, 1);
          $xfer += $this->invalidProductException->write($output);
          $xfer += $output->writeFieldEnd();
        }
        if ($this->validationException !== null) {
          $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 2);
          $xfer += $this->validationException->write($output);
          $xfer += $output->writeFieldEnd();
        }
        if ($this->authorizationException !== null) {
          $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 3);
          $xfer += $this->authorizationException->write($output);
          $xfer += $output->writeFieldEnd();
        }
        if ($this->internalSystemException !== null) {
          $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 4);
          $xfer += $this->internalSystemException->write($output);
          $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
      }

    }

?>
