<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace Gyg\Thrift\Service\SupplierApi;


interface SupplierApiIf {
  /**
   * Original thrift definition:-
   * AvailabilityResponse
   *   getAvailabilities(1: string productId,
   *                     2: string fromDateTime,
   *                     3: string toDateTime)
   *   throws (1: InvalidProductException invalidProductException,
   *           2: ValidationException validationException,
   *           3: AuthorizationException authorizationException,
   *           4: InternalSystemException internalSystemException);
   */
  public function getAvailabilities($productId, $fromDateTime, $toDateTime);

  /**
   * Original thrift definition:-
   * ReservationResponse
   *   reserve(1: ReservationRequest reservationRequest)
   *   throws (1: NoAvailabilityException noAvailabilityException,
   *           2: InvalidProductException invalidProductException,
   *           5: ValidationException validationException,
   *           6: AuthorizationException authorizationException,
   *           7: InternalSystemException internalSystemException);
   */
  public function reserve($reservationRequest);

  /**
   * Original thrift definition:-
   * BookingResponse
   *   book(1: BookingRequest bookingRequest)
   *   throws (1: NoAvailabilityException noAvailabilityException,
   *           2: InvalidProductException invalidProductException,
   *           3: InvalidReservationException invalidReservationException,
   *           4: ValidationException validationException,
   *           5: AuthorizationException authorizationException,
   *           6: InternalSystemException internalSystemException);
   */
  public function book($bookingRequest);

  /**
   * Original thrift definition:-
   * void
   *   cancelReservation(1: ReservationCancelation reservationCancelation)
   *   throws (1: InvalidReservationException invalidReservationException,
   *           2: ValidationException validationException,
   *           3: AuthorizationException authorizationException,
   *           4: InternalSystemException internalSystemException);
   */
  public function cancelReservation($reservationCancelation);

  /**
   * Original thrift definition:-
   * void
   *   cancelBooking(1: BookingCancelation bookingCancelation)
   *   throws (1: InvalidBookingException invalidBookingException,
   *           2: ValidationException validationException,
   *           3: AuthorizationException authorizationException,
   *           4: InternalSystemException internalSystemException);
   */
  public function cancelBooking($bookingCancelation);
}

class SupplierApiClient implements SupplierApiIf, \IThriftClient {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct(\TProtocol $input, /*?\TProtocol*/ $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
    $this->eventHandler_ = new \TClientEventHandler();
  }

  public function setEventHandler(\TClientEventHandler $event_handler) {
    $this->eventHandler_ = $event_handler;
  }

  public function getEventHandler() {
    return $this->eventHandler_;
  }

  private function getsequenceid() {
    $currentseqid = $this->seqid_;
    if ($this->seqid_ >= 0x7fffffff) {
       $this->seqid_ = 0;
    } else {
       $this->seqid_++;
    }
    return $currentseqid;
  }

  /**
   * Original thrift definition:-
   * AvailabilityResponse
   *   getAvailabilities(1: string productId,
   *                     2: string fromDateTime,
   *                     3: string toDateTime)
   *   throws (1: InvalidProductException invalidProductException,
   *           2: ValidationException validationException,
   *           3: AuthorizationException authorizationException,
   *           4: InternalSystemException internalSystemException);
   */
  public function getAvailabilities($productId, $fromDateTime, $toDateTime)
  {
    $currentseqid = $this->send_getAvailabilities($productId, $fromDateTime, $toDateTime);
    return $this->recv_getAvailabilities($currentseqid);
  }

  public function send_getAvailabilities($productId, $fromDateTime, $toDateTime)
  {
    $currentseqid = $this->getsequenceid();
    $args = new SupplierApi_getAvailabilities_args();
    $args->productId = $productId;
    $args->fromDateTime = $fromDateTime;
    $args->toDateTime = $toDateTime;
    try {
      $this->eventHandler_->preSend('getAvailabilities', $args, $currentseqid);
      $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
      $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel)
      {
        thrift_protocol_write_binary($this->output_, 'getAvailabilities', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($compact_accel)
      {
        thrift_protocol_write_compact($this->output_, 'getAvailabilities', \TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('getAvailabilities', \TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('getAvailabilities', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('getAvailabilities', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->sendError('getAvailabilities', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('getAvailabilities', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_getAvailabilities($expectedsequenceid = null)
  {
    try {
      $this->eventHandler_->preRecv('getAvailabilities', $expectedsequenceid);
      $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
      $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'SupplierApi_getAvailabilities_result', $this->input_->isStrictRead());
      else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'SupplierApi_getAvailabilities_result');
      else
      {
        $rseqid = 0;
        $fname = null;
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == \TMessageType::EXCEPTION) {
          $x = new \TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new SupplierApi_getAvailabilities_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
          throw new \TProtocolException("getAvailabilities failed: sequence id is out of order");
        }
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('getAvailabilities', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('getAvailabilities', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('getAvailabilities', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->recvError('getAvailabilities', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->success !== null) {
      $this->eventHandler_->postRecv('getAvailabilities', $expectedsequenceid, $result->success);
      return $result->success;
    }
    if ($result->invalidProductException !== null) {
      $this->eventHandler_->recvException('getAvailabilities', $expectedsequenceid, $result->invalidProductException);
      throw $result->invalidProductException;
    }
    if ($result->validationException !== null) {
      $this->eventHandler_->recvException('getAvailabilities', $expectedsequenceid, $result->validationException);
      throw $result->validationException;
    }
    if ($result->authorizationException !== null) {
      $this->eventHandler_->recvException('getAvailabilities', $expectedsequenceid, $result->authorizationException);
      throw $result->authorizationException;
    }
    if ($result->internalSystemException !== null) {
      $this->eventHandler_->recvException('getAvailabilities', $expectedsequenceid, $result->internalSystemException);
      throw $result->internalSystemException;
    }
    $x = new \TApplicationException("getAvailabilities failed: unknown result", \TApplicationException::MISSING_RESULT);
    $this->eventHandler_->recvError('getAvailabilities', $expectedsequenceid, $x);
    throw $x;
  }

  /**
   * Original thrift definition:-
   * ReservationResponse
   *   reserve(1: ReservationRequest reservationRequest)
   *   throws (1: NoAvailabilityException noAvailabilityException,
   *           2: InvalidProductException invalidProductException,
   *           5: ValidationException validationException,
   *           6: AuthorizationException authorizationException,
   *           7: InternalSystemException internalSystemException);
   */
  public function reserve($reservationRequest)
  {
    $currentseqid = $this->send_reserve($reservationRequest);
    return $this->recv_reserve($currentseqid);
  }

  public function send_reserve($reservationRequest)
  {
    $currentseqid = $this->getsequenceid();
    $args = new SupplierApi_reserve_args();
    $args->reservationRequest = $reservationRequest;
    try {
      $this->eventHandler_->preSend('reserve', $args, $currentseqid);
      $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
      $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel)
      {
        thrift_protocol_write_binary($this->output_, 'reserve', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($compact_accel)
      {
        thrift_protocol_write_compact($this->output_, 'reserve', \TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('reserve', \TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('reserve', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('reserve', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->sendError('reserve', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('reserve', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_reserve($expectedsequenceid = null)
  {
    try {
      $this->eventHandler_->preRecv('reserve', $expectedsequenceid);
      $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
      $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'SupplierApi_reserve_result', $this->input_->isStrictRead());
      else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'SupplierApi_reserve_result');
      else
      {
        $rseqid = 0;
        $fname = null;
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == \TMessageType::EXCEPTION) {
          $x = new \TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new SupplierApi_reserve_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
          throw new \TProtocolException("reserve failed: sequence id is out of order");
        }
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('reserve', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('reserve', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('reserve', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->recvError('reserve', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->success !== null) {
      $this->eventHandler_->postRecv('reserve', $expectedsequenceid, $result->success);
      return $result->success;
    }
    if ($result->noAvailabilityException !== null) {
      $this->eventHandler_->recvException('reserve', $expectedsequenceid, $result->noAvailabilityException);
      throw $result->noAvailabilityException;
    }
    if ($result->invalidProductException !== null) {
      $this->eventHandler_->recvException('reserve', $expectedsequenceid, $result->invalidProductException);
      throw $result->invalidProductException;
    }
    if ($result->validationException !== null) {
      $this->eventHandler_->recvException('reserve', $expectedsequenceid, $result->validationException);
      throw $result->validationException;
    }
    if ($result->authorizationException !== null) {
      $this->eventHandler_->recvException('reserve', $expectedsequenceid, $result->authorizationException);
      throw $result->authorizationException;
    }
    if ($result->internalSystemException !== null) {
      $this->eventHandler_->recvException('reserve', $expectedsequenceid, $result->internalSystemException);
      throw $result->internalSystemException;
    }
    $x = new \TApplicationException("reserve failed: unknown result", \TApplicationException::MISSING_RESULT);
    $this->eventHandler_->recvError('reserve', $expectedsequenceid, $x);
    throw $x;
  }

  /**
   * Original thrift definition:-
   * BookingResponse
   *   book(1: BookingRequest bookingRequest)
   *   throws (1: NoAvailabilityException noAvailabilityException,
   *           2: InvalidProductException invalidProductException,
   *           3: InvalidReservationException invalidReservationException,
   *           4: ValidationException validationException,
   *           5: AuthorizationException authorizationException,
   *           6: InternalSystemException internalSystemException);
   */
  public function book($bookingRequest)
  {
    $currentseqid = $this->send_book($bookingRequest);
    return $this->recv_book($currentseqid);
  }

  public function send_book($bookingRequest)
  {
    $currentseqid = $this->getsequenceid();
    $args = new SupplierApi_book_args();
    $args->bookingRequest = $bookingRequest;
    try {
      $this->eventHandler_->preSend('book', $args, $currentseqid);
      $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
      $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel)
      {
        thrift_protocol_write_binary($this->output_, 'book', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($compact_accel)
      {
        thrift_protocol_write_compact($this->output_, 'book', \TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('book', \TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('book', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('book', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->sendError('book', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('book', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_book($expectedsequenceid = null)
  {
    try {
      $this->eventHandler_->preRecv('book', $expectedsequenceid);
      $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
      $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'SupplierApi_book_result', $this->input_->isStrictRead());
      else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'SupplierApi_book_result');
      else
      {
        $rseqid = 0;
        $fname = null;
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == \TMessageType::EXCEPTION) {
          $x = new \TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new SupplierApi_book_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
          throw new \TProtocolException("book failed: sequence id is out of order");
        }
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('book', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('book', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('book', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->recvError('book', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->success !== null) {
      $this->eventHandler_->postRecv('book', $expectedsequenceid, $result->success);
      return $result->success;
    }
    if ($result->noAvailabilityException !== null) {
      $this->eventHandler_->recvException('book', $expectedsequenceid, $result->noAvailabilityException);
      throw $result->noAvailabilityException;
    }
    if ($result->invalidProductException !== null) {
      $this->eventHandler_->recvException('book', $expectedsequenceid, $result->invalidProductException);
      throw $result->invalidProductException;
    }
    if ($result->invalidReservationException !== null) {
      $this->eventHandler_->recvException('book', $expectedsequenceid, $result->invalidReservationException);
      throw $result->invalidReservationException;
    }
    if ($result->validationException !== null) {
      $this->eventHandler_->recvException('book', $expectedsequenceid, $result->validationException);
      throw $result->validationException;
    }
    if ($result->authorizationException !== null) {
      $this->eventHandler_->recvException('book', $expectedsequenceid, $result->authorizationException);
      throw $result->authorizationException;
    }
    if ($result->internalSystemException !== null) {
      $this->eventHandler_->recvException('book', $expectedsequenceid, $result->internalSystemException);
      throw $result->internalSystemException;
    }
    $x = new \TApplicationException("book failed: unknown result", \TApplicationException::MISSING_RESULT);
    $this->eventHandler_->recvError('book', $expectedsequenceid, $x);
    throw $x;
  }

  /**
   * Original thrift definition:-
   * void
   *   cancelReservation(1: ReservationCancelation reservationCancelation)
   *   throws (1: InvalidReservationException invalidReservationException,
   *           2: ValidationException validationException,
   *           3: AuthorizationException authorizationException,
   *           4: InternalSystemException internalSystemException);
   */
  public function cancelReservation($reservationCancelation)
  {
    $currentseqid = $this->send_cancelReservation($reservationCancelation);
    $this->recv_cancelReservation($currentseqid);
  }

  public function send_cancelReservation($reservationCancelation)
  {
    $currentseqid = $this->getsequenceid();
    $args = new SupplierApi_cancelReservation_args();
    $args->reservationCancelation = $reservationCancelation;
    try {
      $this->eventHandler_->preSend('cancelReservation', $args, $currentseqid);
      $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
      $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel)
      {
        thrift_protocol_write_binary($this->output_, 'cancelReservation', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($compact_accel)
      {
        thrift_protocol_write_compact($this->output_, 'cancelReservation', \TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('cancelReservation', \TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('cancelReservation', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('cancelReservation', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->sendError('cancelReservation', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('cancelReservation', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_cancelReservation($expectedsequenceid = null)
  {
    try {
      $this->eventHandler_->preRecv('cancelReservation', $expectedsequenceid);
      $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
      $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'SupplierApi_cancelReservation_result', $this->input_->isStrictRead());
      else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'SupplierApi_cancelReservation_result');
      else
      {
        $rseqid = 0;
        $fname = null;
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == \TMessageType::EXCEPTION) {
          $x = new \TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new SupplierApi_cancelReservation_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
          throw new \TProtocolException("cancelReservation failed: sequence id is out of order");
        }
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('cancelReservation', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('cancelReservation', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('cancelReservation', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->recvError('cancelReservation', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->invalidReservationException !== null) {
      $this->eventHandler_->recvException('cancelReservation', $expectedsequenceid, $result->invalidReservationException);
      throw $result->invalidReservationException;
    }
    if ($result->validationException !== null) {
      $this->eventHandler_->recvException('cancelReservation', $expectedsequenceid, $result->validationException);
      throw $result->validationException;
    }
    if ($result->authorizationException !== null) {
      $this->eventHandler_->recvException('cancelReservation', $expectedsequenceid, $result->authorizationException);
      throw $result->authorizationException;
    }
    if ($result->internalSystemException !== null) {
      $this->eventHandler_->recvException('cancelReservation', $expectedsequenceid, $result->internalSystemException);
      throw $result->internalSystemException;
    }
    $this->eventHandler_->postRecv('cancelReservation', $expectedsequenceid, null);
    return;
  }

  /**
   * Original thrift definition:-
   * void
   *   cancelBooking(1: BookingCancelation bookingCancelation)
   *   throws (1: InvalidBookingException invalidBookingException,
   *           2: ValidationException validationException,
   *           3: AuthorizationException authorizationException,
   *           4: InternalSystemException internalSystemException);
   */
  public function cancelBooking($bookingCancelation)
  {
    $currentseqid = $this->send_cancelBooking($bookingCancelation);
    $this->recv_cancelBooking($currentseqid);
  }

  public function send_cancelBooking($bookingCancelation)
  {
    $currentseqid = $this->getsequenceid();
    $args = new SupplierApi_cancelBooking_args();
    $args->bookingCancelation = $bookingCancelation;
    try {
      $this->eventHandler_->preSend('cancelBooking', $args, $currentseqid);
      $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
      $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel)
      {
        thrift_protocol_write_binary($this->output_, 'cancelBooking', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($compact_accel)
      {
        thrift_protocol_write_compact($this->output_, 'cancelBooking', \TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('cancelBooking', \TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('cancelBooking', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('cancelBooking', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->sendError('cancelBooking', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('cancelBooking', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_cancelBooking($expectedsequenceid = null)
  {
    try {
      $this->eventHandler_->preRecv('cancelBooking', $expectedsequenceid);
      $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
      $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
      if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'SupplierApi_cancelBooking_result', $this->input_->isStrictRead());
      else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'SupplierApi_cancelBooking_result');
      else
      {
        $rseqid = 0;
        $fname = null;
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == \TMessageType::EXCEPTION) {
          $x = new \TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new SupplierApi_cancelBooking_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
          throw new \TProtocolException("cancelBooking failed: sequence id is out of order");
        }
      }
    } catch (\THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case \THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('cancelBooking', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('cancelBooking', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case \THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('cancelBooking', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (\Exception $ex) {
      $this->eventHandler_->recvError('cancelBooking', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->invalidBookingException !== null) {
      $this->eventHandler_->recvException('cancelBooking', $expectedsequenceid, $result->invalidBookingException);
      throw $result->invalidBookingException;
    }
    if ($result->validationException !== null) {
      $this->eventHandler_->recvException('cancelBooking', $expectedsequenceid, $result->validationException);
      throw $result->validationException;
    }
    if ($result->authorizationException !== null) {
      $this->eventHandler_->recvException('cancelBooking', $expectedsequenceid, $result->authorizationException);
      throw $result->authorizationException;
    }
    if ($result->internalSystemException !== null) {
      $this->eventHandler_->recvException('cancelBooking', $expectedsequenceid, $result->internalSystemException);
      throw $result->internalSystemException;
    }
    $this->eventHandler_->postRecv('cancelBooking', $expectedsequenceid, null);
    return;
  }

}

class SupplierApiProcessor implements \IThriftProcessor {
  protected $handler_ = null;
  protected $eventHandler_ = null;
  protected $exceptionHandler_ = null;
  public function __construct(SupplierApiIf $handler) {
    $this->handler_ = $handler;
    $this->eventHandler_ = new \TProcessorEventHandler();
  }

  public function setEventHandler(\TProcessorEventHandler $event_handler) {
    $this->eventHandler_ = $event_handler;
  }

  public function getEventHandler() {
    return $this->eventHandler_;
  }

  public function setExceptionHandler(\IProcessorExceptionHandler $exception_handler) {
    $this->exceptionHandler_ = $exception_handler;
  }

  public function getExceptionHandler() {
    return $this->exceptionHandler_;
  }

  public function process(\TProtocol $input, \TProtocol $output) {
    $rseqid = 0;
    $fname = null;
    $mtype = 0;

    $input->readMessageBegin($fname, $mtype, $rseqid);
    $methodname = 'process_'.$fname;
    if (!method_exists($this, $methodname)) {
      $handler_ctx = $this->eventHandler_->getHandlerContext($methodname);
      $this->eventHandler_->preRead($handler_ctx, $methodname, array());
      $input->skip(\TType::STRUCT);
      $input->readMessageEnd();
      $this->eventHandler_->postRead($handler_ctx, $methodname, array());
      $x = new \TApplicationException('Function '.$fname.' not implemented.', \TApplicationException::UNKNOWN_METHOD);
      $this->eventHandler_->handlerError($handler_ctx, $methodname, $x);
      $output->writeMessageBegin($fname, \TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $this->$methodname($rseqid, $input, $output);
    return true;
  }

  protected function process_getAvailabilities($seqid, \TProtocol $input, \TProtocol $output) {
    $handler_ctx = $this->eventHandler_->getHandlerContext('getAvailabilities');
    $reply_type = \TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'getAvailabilities', array());

    $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
    $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

    if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'SupplierApi_getAvailabilities_args');
    else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'SupplierApi_getAvailabilities_args');
    else {
      $args = new SupplierApi_getAvailabilities_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'getAvailabilities', $args);
    $result = new SupplierApi_getAvailabilities_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'getAvailabilities', $args);
      try {
        $result->success = $this->handler_->getAvailabilities($args->productId, $args->fromDateTime, $args->toDateTime);
      } catch (\Exception $e) {
        if ($this->exceptionHandler_ === null) {
          throw  $e;
        } else {
          $this->exceptionHandler_->handle('getAvailabilities', $e);
        }
      }
      $this->eventHandler_->postExec($handler_ctx, 'getAvailabilities', $result);
    } catch (InvalidProductException $exc0) {
      $this->eventHandler_->handlerException($handler_ctx, 'getAvailabilities', $exc0);
      $result->invalidProductException = $exc0;
    } catch (ValidationException $exc1) {
      $this->eventHandler_->handlerException($handler_ctx, 'getAvailabilities', $exc1);
      $result->validationException = $exc1;
    } catch (AuthorizationException $exc2) {
      $this->eventHandler_->handlerException($handler_ctx, 'getAvailabilities', $exc2);
      $result->authorizationException = $exc2;
    } catch (InternalSystemException $exc3) {
      $this->eventHandler_->handlerException($handler_ctx, 'getAvailabilities', $exc3);
      $result->internalSystemException = $exc3;
    } catch (\Exception $ex) {
      $reply_type = \TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'getAvailabilities', $ex);
      $result = new \TApplicationException($ex->getMessage());
    }
    $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
    $this->eventHandler_->preWrite($handler_ctx, 'getAvailabilities', $result);
    if ($bin_accel)
    {
      thrift_protocol_write_binary($output, 'getAvailabilities', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($compact_accel)
    {
      thrift_protocol_write_compact($output, 'getAvailabilities', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("getAvailabilities", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'getAvailabilities', $result);
  }
  protected function process_reserve($seqid, \TProtocol $input, \TProtocol $output) {
    $handler_ctx = $this->eventHandler_->getHandlerContext('reserve');
    $reply_type = \TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'reserve', array());

    $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
    $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

    if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'SupplierApi_reserve_args');
    else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'SupplierApi_reserve_args');
    else {
      $args = new SupplierApi_reserve_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'reserve', $args);
    $result = new SupplierApi_reserve_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'reserve', $args);
      try {
        $result->success = $this->handler_->reserve($args->reservationRequest);
      } catch (\Exception $e) {
        if ($this->exceptionHandler_ === null) {
          throw  $e;
        } else {
          $this->exceptionHandler_->handle('reserve', $e);
        }
      }
      $this->eventHandler_->postExec($handler_ctx, 'reserve', $result);
    } catch (NoAvailabilityException $exc0) {
      $this->eventHandler_->handlerException($handler_ctx, 'reserve', $exc0);
      $result->noAvailabilityException = $exc0;
    } catch (InvalidProductException $exc1) {
      $this->eventHandler_->handlerException($handler_ctx, 'reserve', $exc1);
      $result->invalidProductException = $exc1;
    } catch (ValidationException $exc2) {
      $this->eventHandler_->handlerException($handler_ctx, 'reserve', $exc2);
      $result->validationException = $exc2;
    } catch (AuthorizationException $exc3) {
      $this->eventHandler_->handlerException($handler_ctx, 'reserve', $exc3);
      $result->authorizationException = $exc3;
    } catch (InternalSystemException $exc4) {
      $this->eventHandler_->handlerException($handler_ctx, 'reserve', $exc4);
      $result->internalSystemException = $exc4;
    } catch (\Exception $ex) {
      $reply_type = \TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'reserve', $ex);
      $result = new \TApplicationException($ex->getMessage());
    }
    $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
    $this->eventHandler_->preWrite($handler_ctx, 'reserve', $result);
    if ($bin_accel)
    {
      thrift_protocol_write_binary($output, 'reserve', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($compact_accel)
    {
      thrift_protocol_write_compact($output, 'reserve', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("reserve", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'reserve', $result);
  }
  protected function process_book($seqid, \TProtocol $input, \TProtocol $output) {
    $handler_ctx = $this->eventHandler_->getHandlerContext('book');
    $reply_type = \TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'book', array());

    $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
    $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

    if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'SupplierApi_book_args');
    else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'SupplierApi_book_args');
    else {
      $args = new SupplierApi_book_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'book', $args);
    $result = new SupplierApi_book_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'book', $args);
      try {
        $result->success = $this->handler_->book($args->bookingRequest);
      } catch (\Exception $e) {
        if ($this->exceptionHandler_ === null) {
          throw  $e;
        } else {
          $this->exceptionHandler_->handle('book', $e);
        }
      }
      $this->eventHandler_->postExec($handler_ctx, 'book', $result);
    } catch (NoAvailabilityException $exc0) {
      $this->eventHandler_->handlerException($handler_ctx, 'book', $exc0);
      $result->noAvailabilityException = $exc0;
    } catch (InvalidProductException $exc1) {
      $this->eventHandler_->handlerException($handler_ctx, 'book', $exc1);
      $result->invalidProductException = $exc1;
    } catch (InvalidReservationException $exc2) {
      $this->eventHandler_->handlerException($handler_ctx, 'book', $exc2);
      $result->invalidReservationException = $exc2;
    } catch (ValidationException $exc3) {
      $this->eventHandler_->handlerException($handler_ctx, 'book', $exc3);
      $result->validationException = $exc3;
    } catch (AuthorizationException $exc4) {
      $this->eventHandler_->handlerException($handler_ctx, 'book', $exc4);
      $result->authorizationException = $exc4;
    } catch (InternalSystemException $exc5) {
      $this->eventHandler_->handlerException($handler_ctx, 'book', $exc5);
      $result->internalSystemException = $exc5;
    } catch (\Exception $ex) {
      $reply_type = \TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'book', $ex);
      $result = new \TApplicationException($ex->getMessage());
    }
    $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
    $this->eventHandler_->preWrite($handler_ctx, 'book', $result);
    if ($bin_accel)
    {
      thrift_protocol_write_binary($output, 'book', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($compact_accel)
    {
      thrift_protocol_write_compact($output, 'book', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("book", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'book', $result);
  }
  protected function process_cancelReservation($seqid, \TProtocol $input, \TProtocol $output) {
    $handler_ctx = $this->eventHandler_->getHandlerContext('cancelReservation');
    $reply_type = \TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'cancelReservation', array());

    $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
    $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

    if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'SupplierApi_cancelReservation_args');
    else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'SupplierApi_cancelReservation_args');
    else {
      $args = new SupplierApi_cancelReservation_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'cancelReservation', $args);
    $result = new SupplierApi_cancelReservation_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'cancelReservation', $args);
      try {
        $this->handler_->cancelReservation($args->reservationCancelation);
      } catch (\Exception $e) {
        if ($this->exceptionHandler_ === null) {
          throw  $e;
        } else {
          $this->exceptionHandler_->handle('cancelReservation', $e);
        }
      }
      $this->eventHandler_->postExec($handler_ctx, 'cancelReservation', $result);
    } catch (InvalidReservationException $exc0) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelReservation', $exc0);
      $result->invalidReservationException = $exc0;
    } catch (ValidationException $exc1) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelReservation', $exc1);
      $result->validationException = $exc1;
    } catch (AuthorizationException $exc2) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelReservation', $exc2);
      $result->authorizationException = $exc2;
    } catch (InternalSystemException $exc3) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelReservation', $exc3);
      $result->internalSystemException = $exc3;
    } catch (\Exception $ex) {
      $reply_type = \TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'cancelReservation', $ex);
      $result = new \TApplicationException($ex->getMessage());
    }
    $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
    $this->eventHandler_->preWrite($handler_ctx, 'cancelReservation', $result);
    if ($bin_accel)
    {
      thrift_protocol_write_binary($output, 'cancelReservation', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($compact_accel)
    {
      thrift_protocol_write_compact($output, 'cancelReservation', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("cancelReservation", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'cancelReservation', $result);
  }
  protected function process_cancelBooking($seqid, \TProtocol $input, \TProtocol $output) {
    $handler_ctx = $this->eventHandler_->getHandlerContext('cancelBooking');
    $reply_type = \TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'cancelBooking', array());

    $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
    $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

    if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'SupplierApi_cancelBooking_args');
    else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'SupplierApi_cancelBooking_args');
    else {
      $args = new SupplierApi_cancelBooking_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'cancelBooking', $args);
    $result = new SupplierApi_cancelBooking_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'cancelBooking', $args);
      try {
        $this->handler_->cancelBooking($args->bookingCancelation);
      } catch (\Exception $e) {
        if ($this->exceptionHandler_ === null) {
          throw  $e;
        } else {
          $this->exceptionHandler_->handle('cancelBooking', $e);
        }
      }
      $this->eventHandler_->postExec($handler_ctx, 'cancelBooking', $result);
    } catch (InvalidBookingException $exc0) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelBooking', $exc0);
      $result->invalidBookingException = $exc0;
    } catch (ValidationException $exc1) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelBooking', $exc1);
      $result->validationException = $exc1;
    } catch (AuthorizationException $exc2) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelBooking', $exc2);
      $result->authorizationException = $exc2;
    } catch (InternalSystemException $exc3) {
      $this->eventHandler_->handlerException($handler_ctx, 'cancelBooking', $exc3);
      $result->internalSystemException = $exc3;
    } catch (\Exception $ex) {
      $reply_type = \TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'cancelBooking', $ex);
      $result = new \TApplicationException($ex->getMessage());
    }
    $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
    $this->eventHandler_->preWrite($handler_ctx, 'cancelBooking', $result);
    if ($bin_accel)
    {
      thrift_protocol_write_binary($output, 'cancelBooking', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($compact_accel)
    {
      thrift_protocol_write_compact($output, 'cancelBooking', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("cancelBooking", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'cancelBooking', $result);
  }
}
// HELPER FUNCTIONS AND STRUCTURES

class SupplierApi_getAvailabilities_args implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'productId',
        'type' => \TType::STRING,
        ),
      2 => array(
        'var' => 'fromDateTime',
        'type' => \TType::STRING,
        ),
      3 => array(
        'var' => 'toDateTime',
        'type' => \TType::STRING,
        ),
      );
    public static $_TFIELDMAP = array(
      'productId' => 1,
      'fromDateTime' => 2,
      'toDateTime' => 3,
    );
    const STRUCTURAL_ID = 2810007422305526495;
    public $productId = null;
    public $fromDateTime = null;
    public $toDateTime = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['productId'])) {
          $this->productId = $vals['productId'];
        }
        if (isset($vals['fromDateTime'])) {
          $this->fromDateTime = $vals['fromDateTime'];
        }
        if (isset($vals['toDateTime'])) {
          $this->toDateTime = $vals['toDateTime'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_getAvailabilities_args constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_getAvailabilities_args';
    }

    public static function __set_state($vals) {
      return new SupplierApi_getAvailabilities_args($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRING) {
              $xfer += $input->readString($this->productId);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 2:
            if ($ftype == \TType::STRING) {
              $xfer += $input->readString($this->fromDateTime);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 3:
            if ($ftype == \TType::STRING) {
              $xfer += $input->readString($this->toDateTime);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_getAvailabilities_args');
      if ($this->productId !== null) {
        $xfer += $output->writeFieldBegin('productId', \TType::STRING, 1);
        $xfer += $output->writeString($this->productId);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->fromDateTime !== null) {
        $xfer += $output->writeFieldBegin('fromDateTime', \TType::STRING, 2);
        $xfer += $output->writeString($this->fromDateTime);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->toDateTime !== null) {
        $xfer += $output->writeFieldBegin('toDateTime', \TType::STRING, 3);
        $xfer += $output->writeString($this->toDateTime);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_getAvailabilities_result implements \IThriftStruct {
    static $_TSPEC = array(
      0 => array(
        'var' => 'success',
        'type' => \TType::STRUCT,
        'class' => 'AvailabilityResponse',
        ),
      1 => array(
        'var' => 'invalidProductException',
        'type' => \TType::STRUCT,
        'class' => 'InvalidProductException',
        ),
      2 => array(
        'var' => 'validationException',
        'type' => \TType::STRUCT,
        'class' => 'ValidationException',
        ),
      3 => array(
        'var' => 'authorizationException',
        'type' => \TType::STRUCT,
        'class' => 'AuthorizationException',
        ),
      4 => array(
        'var' => 'internalSystemException',
        'type' => \TType::STRUCT,
        'class' => 'InternalSystemException',
        ),
      );
    public static $_TFIELDMAP = array(
      'success' => 0,
      'invalidProductException' => 1,
      'validationException' => 2,
      'authorizationException' => 3,
      'internalSystemException' => 4,
    );
    const STRUCTURAL_ID = 6480584235992634646;
    public $success = null;
    public $invalidProductException = null;
    public $validationException = null;
    public $authorizationException = null;
    public $internalSystemException = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['success'])) {
          $this->success = $vals['success'];
        }
        if (isset($vals['invalidProductException'])) {
          $this->invalidProductException = $vals['invalidProductException'];
        }
        if (isset($vals['validationException'])) {
          $this->validationException = $vals['validationException'];
        }
        if (isset($vals['authorizationException'])) {
          $this->authorizationException = $vals['authorizationException'];
        }
        if (isset($vals['internalSystemException'])) {
          $this->internalSystemException = $vals['internalSystemException'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_getAvailabilities_result constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_getAvailabilities_result';
    }

    public static function __set_state($vals) {
      return new SupplierApi_getAvailabilities_result($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 0:
            if ($ftype == \TType::STRUCT) {
              $this->success = new AvailabilityResponse();
              $xfer += $this->success->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->invalidProductException = new InvalidProductException();
              $xfer += $this->invalidProductException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 2:
            if ($ftype == \TType::STRUCT) {
              $this->validationException = new ValidationException();
              $xfer += $this->validationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 3:
            if ($ftype == \TType::STRUCT) {
              $this->authorizationException = new AuthorizationException();
              $xfer += $this->authorizationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 4:
            if ($ftype == \TType::STRUCT) {
              $this->internalSystemException = new InternalSystemException();
              $xfer += $this->internalSystemException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_getAvailabilities_result');
      if ($this->success !== null) {
        if (!is_object($this->success)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('success', \TType::STRUCT, 0);
        $xfer += $this->success->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->invalidProductException !== null) {
        $xfer += $output->writeFieldBegin('invalidProductException', \TType::STRUCT, 1);
        $xfer += $this->invalidProductException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->validationException !== null) {
        $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 2);
        $xfer += $this->validationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->authorizationException !== null) {
        $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 3);
        $xfer += $this->authorizationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->internalSystemException !== null) {
        $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 4);
        $xfer += $this->internalSystemException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_reserve_args implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'reservationRequest',
        'type' => \TType::STRUCT,
        'class' => 'ReservationRequest',
        ),
      );
    public static $_TFIELDMAP = array(
      'reservationRequest' => 1,
    );
    const STRUCTURAL_ID = 7150557541579316602;
    public $reservationRequest = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['reservationRequest'])) {
          $this->reservationRequest = $vals['reservationRequest'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_reserve_args constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_reserve_args';
    }

    public static function __set_state($vals) {
      return new SupplierApi_reserve_args($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->reservationRequest = new ReservationRequest();
              $xfer += $this->reservationRequest->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_reserve_args');
      if ($this->reservationRequest !== null) {
        if (!is_object($this->reservationRequest)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('reservationRequest', \TType::STRUCT, 1);
        $xfer += $this->reservationRequest->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_reserve_result implements \IThriftStruct {
    static $_TSPEC = array(
      0 => array(
        'var' => 'success',
        'type' => \TType::STRUCT,
        'class' => 'ReservationResponse',
        ),
      1 => array(
        'var' => 'noAvailabilityException',
        'type' => \TType::STRUCT,
        'class' => 'NoAvailabilityException',
        ),
      2 => array(
        'var' => 'invalidProductException',
        'type' => \TType::STRUCT,
        'class' => 'InvalidProductException',
        ),
      5 => array(
        'var' => 'validationException',
        'type' => \TType::STRUCT,
        'class' => 'ValidationException',
        ),
      6 => array(
        'var' => 'authorizationException',
        'type' => \TType::STRUCT,
        'class' => 'AuthorizationException',
        ),
      7 => array(
        'var' => 'internalSystemException',
        'type' => \TType::STRUCT,
        'class' => 'InternalSystemException',
        ),
      );
    public static $_TFIELDMAP = array(
      'success' => 0,
      'noAvailabilityException' => 1,
      'invalidProductException' => 2,
      'validationException' => 5,
      'authorizationException' => 6,
      'internalSystemException' => 7,
    );
    const STRUCTURAL_ID = 6896659218634481011;
    public $success = null;
    public $noAvailabilityException = null;
    public $invalidProductException = null;
    public $validationException = null;
    public $authorizationException = null;
    public $internalSystemException = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['success'])) {
          $this->success = $vals['success'];
        }
        if (isset($vals['noAvailabilityException'])) {
          $this->noAvailabilityException = $vals['noAvailabilityException'];
        }
        if (isset($vals['invalidProductException'])) {
          $this->invalidProductException = $vals['invalidProductException'];
        }
        if (isset($vals['validationException'])) {
          $this->validationException = $vals['validationException'];
        }
        if (isset($vals['authorizationException'])) {
          $this->authorizationException = $vals['authorizationException'];
        }
        if (isset($vals['internalSystemException'])) {
          $this->internalSystemException = $vals['internalSystemException'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_reserve_result constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_reserve_result';
    }

    public static function __set_state($vals) {
      return new SupplierApi_reserve_result($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 0:
            if ($ftype == \TType::STRUCT) {
              $this->success = new ReservationResponse();
              $xfer += $this->success->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->noAvailabilityException = new NoAvailabilityException();
              $xfer += $this->noAvailabilityException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 2:
            if ($ftype == \TType::STRUCT) {
              $this->invalidProductException = new InvalidProductException();
              $xfer += $this->invalidProductException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 5:
            if ($ftype == \TType::STRUCT) {
              $this->validationException = new ValidationException();
              $xfer += $this->validationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 6:
            if ($ftype == \TType::STRUCT) {
              $this->authorizationException = new AuthorizationException();
              $xfer += $this->authorizationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 7:
            if ($ftype == \TType::STRUCT) {
              $this->internalSystemException = new InternalSystemException();
              $xfer += $this->internalSystemException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_reserve_result');
      if ($this->success !== null) {
        if (!is_object($this->success)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('success', \TType::STRUCT, 0);
        $xfer += $this->success->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->noAvailabilityException !== null) {
        $xfer += $output->writeFieldBegin('noAvailabilityException', \TType::STRUCT, 1);
        $xfer += $this->noAvailabilityException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->invalidProductException !== null) {
        $xfer += $output->writeFieldBegin('invalidProductException', \TType::STRUCT, 2);
        $xfer += $this->invalidProductException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->validationException !== null) {
        $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 5);
        $xfer += $this->validationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->authorizationException !== null) {
        $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 6);
        $xfer += $this->authorizationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->internalSystemException !== null) {
        $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 7);
        $xfer += $this->internalSystemException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_book_args implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'bookingRequest',
        'type' => \TType::STRUCT,
        'class' => 'BookingRequest',
        ),
      );
    public static $_TFIELDMAP = array(
      'bookingRequest' => 1,
    );
    const STRUCTURAL_ID = 4563648941577842408;
    public $bookingRequest = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['bookingRequest'])) {
          $this->bookingRequest = $vals['bookingRequest'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_book_args constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_book_args';
    }

    public static function __set_state($vals) {
      return new SupplierApi_book_args($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->bookingRequest = new BookingRequest();
              $xfer += $this->bookingRequest->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_book_args');
      if ($this->bookingRequest !== null) {
        if (!is_object($this->bookingRequest)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('bookingRequest', \TType::STRUCT, 1);
        $xfer += $this->bookingRequest->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_book_result implements \IThriftStruct {
    static $_TSPEC = array(
      0 => array(
        'var' => 'success',
        'type' => \TType::STRUCT,
        'class' => 'BookingResponse',
        ),
      1 => array(
        'var' => 'noAvailabilityException',
        'type' => \TType::STRUCT,
        'class' => 'NoAvailabilityException',
        ),
      2 => array(
        'var' => 'invalidProductException',
        'type' => \TType::STRUCT,
        'class' => 'InvalidProductException',
        ),
      3 => array(
        'var' => 'invalidReservationException',
        'type' => \TType::STRUCT,
        'class' => 'InvalidReservationException',
        ),
      4 => array(
        'var' => 'validationException',
        'type' => \TType::STRUCT,
        'class' => 'ValidationException',
        ),
      5 => array(
        'var' => 'authorizationException',
        'type' => \TType::STRUCT,
        'class' => 'AuthorizationException',
        ),
      6 => array(
        'var' => 'internalSystemException',
        'type' => \TType::STRUCT,
        'class' => 'InternalSystemException',
        ),
      );
    public static $_TFIELDMAP = array(
      'success' => 0,
      'noAvailabilityException' => 1,
      'invalidProductException' => 2,
      'invalidReservationException' => 3,
      'validationException' => 4,
      'authorizationException' => 5,
      'internalSystemException' => 6,
    );
    const STRUCTURAL_ID = 1691471950997496809;
    public $success = null;
    public $noAvailabilityException = null;
    public $invalidProductException = null;
    public $invalidReservationException = null;
    public $validationException = null;
    public $authorizationException = null;
    public $internalSystemException = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['success'])) {
          $this->success = $vals['success'];
        }
        if (isset($vals['noAvailabilityException'])) {
          $this->noAvailabilityException = $vals['noAvailabilityException'];
        }
        if (isset($vals['invalidProductException'])) {
          $this->invalidProductException = $vals['invalidProductException'];
        }
        if (isset($vals['invalidReservationException'])) {
          $this->invalidReservationException = $vals['invalidReservationException'];
        }
        if (isset($vals['validationException'])) {
          $this->validationException = $vals['validationException'];
        }
        if (isset($vals['authorizationException'])) {
          $this->authorizationException = $vals['authorizationException'];
        }
        if (isset($vals['internalSystemException'])) {
          $this->internalSystemException = $vals['internalSystemException'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_book_result constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_book_result';
    }

    public static function __set_state($vals) {
      return new SupplierApi_book_result($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 0:
            if ($ftype == \TType::STRUCT) {
              $this->success = new BookingResponse();
              $xfer += $this->success->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->noAvailabilityException = new NoAvailabilityException();
              $xfer += $this->noAvailabilityException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 2:
            if ($ftype == \TType::STRUCT) {
              $this->invalidProductException = new InvalidProductException();
              $xfer += $this->invalidProductException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 3:
            if ($ftype == \TType::STRUCT) {
              $this->invalidReservationException = new InvalidReservationException();
              $xfer += $this->invalidReservationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 4:
            if ($ftype == \TType::STRUCT) {
              $this->validationException = new ValidationException();
              $xfer += $this->validationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 5:
            if ($ftype == \TType::STRUCT) {
              $this->authorizationException = new AuthorizationException();
              $xfer += $this->authorizationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 6:
            if ($ftype == \TType::STRUCT) {
              $this->internalSystemException = new InternalSystemException();
              $xfer += $this->internalSystemException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_book_result');
      if ($this->success !== null) {
        if (!is_object($this->success)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('success', \TType::STRUCT, 0);
        $xfer += $this->success->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->noAvailabilityException !== null) {
        $xfer += $output->writeFieldBegin('noAvailabilityException', \TType::STRUCT, 1);
        $xfer += $this->noAvailabilityException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->invalidProductException !== null) {
        $xfer += $output->writeFieldBegin('invalidProductException', \TType::STRUCT, 2);
        $xfer += $this->invalidProductException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->invalidReservationException !== null) {
        $xfer += $output->writeFieldBegin('invalidReservationException', \TType::STRUCT, 3);
        $xfer += $this->invalidReservationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->validationException !== null) {
        $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 4);
        $xfer += $this->validationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->authorizationException !== null) {
        $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 5);
        $xfer += $this->authorizationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->internalSystemException !== null) {
        $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 6);
        $xfer += $this->internalSystemException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_cancelReservation_args implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'reservationCancelation',
        'type' => \TType::STRUCT,
        'class' => 'ReservationCancelation',
        ),
      );
    public static $_TFIELDMAP = array(
      'reservationCancelation' => 1,
    );
    const STRUCTURAL_ID = 6989183155486937806;
    public $reservationCancelation = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['reservationCancelation'])) {
          $this->reservationCancelation = $vals['reservationCancelation'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_cancelReservation_args constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_cancelReservation_args';
    }

    public static function __set_state($vals) {
      return new SupplierApi_cancelReservation_args($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->reservationCancelation = new ReservationCancelation();
              $xfer += $this->reservationCancelation->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_cancelReservation_args');
      if ($this->reservationCancelation !== null) {
        if (!is_object($this->reservationCancelation)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('reservationCancelation', \TType::STRUCT, 1);
        $xfer += $this->reservationCancelation->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_cancelReservation_result implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'invalidReservationException',
        'type' => \TType::STRUCT,
        'class' => 'InvalidReservationException',
        ),
      2 => array(
        'var' => 'validationException',
        'type' => \TType::STRUCT,
        'class' => 'ValidationException',
        ),
      3 => array(
        'var' => 'authorizationException',
        'type' => \TType::STRUCT,
        'class' => 'AuthorizationException',
        ),
      4 => array(
        'var' => 'internalSystemException',
        'type' => \TType::STRUCT,
        'class' => 'InternalSystemException',
        ),
      );
    public static $_TFIELDMAP = array(
      'invalidReservationException' => 1,
      'validationException' => 2,
      'authorizationException' => 3,
      'internalSystemException' => 4,
    );
    const STRUCTURAL_ID = 2082923664551508719;
    public $invalidReservationException = null;
    public $validationException = null;
    public $authorizationException = null;
    public $internalSystemException = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['invalidReservationException'])) {
          $this->invalidReservationException = $vals['invalidReservationException'];
        }
        if (isset($vals['validationException'])) {
          $this->validationException = $vals['validationException'];
        }
        if (isset($vals['authorizationException'])) {
          $this->authorizationException = $vals['authorizationException'];
        }
        if (isset($vals['internalSystemException'])) {
          $this->internalSystemException = $vals['internalSystemException'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_cancelReservation_result constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_cancelReservation_result';
    }

    public static function __set_state($vals) {
      return new SupplierApi_cancelReservation_result($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->invalidReservationException = new InvalidReservationException();
              $xfer += $this->invalidReservationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 2:
            if ($ftype == \TType::STRUCT) {
              $this->validationException = new ValidationException();
              $xfer += $this->validationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 3:
            if ($ftype == \TType::STRUCT) {
              $this->authorizationException = new AuthorizationException();
              $xfer += $this->authorizationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 4:
            if ($ftype == \TType::STRUCT) {
              $this->internalSystemException = new InternalSystemException();
              $xfer += $this->internalSystemException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_cancelReservation_result');
      if ($this->invalidReservationException !== null) {
        $xfer += $output->writeFieldBegin('invalidReservationException', \TType::STRUCT, 1);
        $xfer += $this->invalidReservationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->validationException !== null) {
        $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 2);
        $xfer += $this->validationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->authorizationException !== null) {
        $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 3);
        $xfer += $this->authorizationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->internalSystemException !== null) {
        $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 4);
        $xfer += $this->internalSystemException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_cancelBooking_args implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'bookingCancelation',
        'type' => \TType::STRUCT,
        'class' => 'BookingCancelation',
        ),
      );
    public static $_TFIELDMAP = array(
      'bookingCancelation' => 1,
    );
    const STRUCTURAL_ID = 7479643274761602522;
    public $bookingCancelation = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['bookingCancelation'])) {
          $this->bookingCancelation = $vals['bookingCancelation'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_cancelBooking_args constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_cancelBooking_args';
    }

    public static function __set_state($vals) {
      return new SupplierApi_cancelBooking_args($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->bookingCancelation = new BookingCancelation();
              $xfer += $this->bookingCancelation->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_cancelBooking_args');
      if ($this->bookingCancelation !== null) {
        if (!is_object($this->bookingCancelation)) {
          throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
        }
        $xfer += $output->writeFieldBegin('bookingCancelation', \TType::STRUCT, 1);
        $xfer += $this->bookingCancelation->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

class SupplierApi_cancelBooking_result implements \IThriftStruct {
    static $_TSPEC = array(
      1 => array(
        'var' => 'invalidBookingException',
        'type' => \TType::STRUCT,
        'class' => 'InvalidBookingException',
        ),
      2 => array(
        'var' => 'validationException',
        'type' => \TType::STRUCT,
        'class' => 'ValidationException',
        ),
      3 => array(
        'var' => 'authorizationException',
        'type' => \TType::STRUCT,
        'class' => 'AuthorizationException',
        ),
      4 => array(
        'var' => 'internalSystemException',
        'type' => \TType::STRUCT,
        'class' => 'InternalSystemException',
        ),
      );
    public static $_TFIELDMAP = array(
      'invalidBookingException' => 1,
      'validationException' => 2,
      'authorizationException' => 3,
      'internalSystemException' => 4,
    );
    const STRUCTURAL_ID = 1827220861277327656;
    public $invalidBookingException = null;
    public $validationException = null;
    public $authorizationException = null;
    public $internalSystemException = null;

    public function __construct($vals=null) {
      if (is_array($vals)) {
        if (isset($vals['invalidBookingException'])) {
          $this->invalidBookingException = $vals['invalidBookingException'];
        }
        if (isset($vals['validationException'])) {
          $this->validationException = $vals['validationException'];
        }
        if (isset($vals['authorizationException'])) {
          $this->authorizationException = $vals['authorizationException'];
        }
        if (isset($vals['internalSystemException'])) {
          $this->internalSystemException = $vals['internalSystemException'];
        }
      } else if ($vals) {
        throw new \TProtocolException(
          'SupplierApi_cancelBooking_result constructor must be passed array or null'
        );
      }
    }

    public function getName() {
      return 'SupplierApi_cancelBooking_result';
    }

    public static function __set_state($vals) {
      return new SupplierApi_cancelBooking_result($vals);
    }

    public function read(\TProtocol $input)
    {
      $xfer = 0;
      $fname = null;
      $ftype = 0;
      $fid = 0;
      $xfer += $input->readStructBegin($fname);
      while (true)
      {
        $xfer += $input->readFieldBegin($fname, $ftype, $fid);
        if ($ftype == \TType::STOP) {
          break;
        }
        if (!$fid && $fname !== null) {
          if (isset(self::$_TFIELDMAP[$fname])) {
            $fid = self::$_TFIELDMAP[$fname];
            $ftype = self::$_TSPEC[$fid]['type'];
          }
        }
        switch ($fid)
        {
          case 1:
            if ($ftype == \TType::STRUCT) {
              $this->invalidBookingException = new InvalidBookingException();
              $xfer += $this->invalidBookingException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 2:
            if ($ftype == \TType::STRUCT) {
              $this->validationException = new ValidationException();
              $xfer += $this->validationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 3:
            if ($ftype == \TType::STRUCT) {
              $this->authorizationException = new AuthorizationException();
              $xfer += $this->authorizationException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          case 4:
            if ($ftype == \TType::STRUCT) {
              $this->internalSystemException = new InternalSystemException();
              $xfer += $this->internalSystemException->read($input);
            } else {
              $xfer += $input->skip($ftype);
            }
            break;
          default:
            $xfer += $input->skip($ftype);
            break;
        }
        $xfer += $input->readFieldEnd();
      }
      $xfer += $input->readStructEnd();
      return $xfer;
    }

    public function write(\TProtocol $output) {
      $xfer = 0;
      $xfer += $output->writeStructBegin('SupplierApi_cancelBooking_result');
      if ($this->invalidBookingException !== null) {
        $xfer += $output->writeFieldBegin('invalidBookingException', \TType::STRUCT, 1);
        $xfer += $this->invalidBookingException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->validationException !== null) {
        $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 2);
        $xfer += $this->validationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->authorizationException !== null) {
        $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 3);
        $xfer += $this->authorizationException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      if ($this->internalSystemException !== null) {
        $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 4);
        $xfer += $this->internalSystemException->write($output);
        $xfer += $output->writeFieldEnd();
      }
      $xfer += $output->writeFieldStop();
      $xfer += $output->writeStructEnd();
      return $xfer;
    }

  }

?>
