<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace Gyg\Thrift\Service\SupplierApi;


interface SupplierApiTestIf {
      /**
       * Original thrift definition:-
       * TestResult
       *   testFunction(1: FunctionToTest functionToTest,
       *                2: TestDataOverride testDataOverride)
       *   throws (1: ValidationException validationException,
       *           2: AuthorizationException authorizationException,
       *           3: InternalSystemException internalSystemException);
       */
      public function testFunction($functionToTest, $testDataOverride);
}

class SupplierApiTestClient implements SupplierApiTestIf, \IThriftClient {
      protected $input_ = null;
      protected $output_ = null;

      protected $seqid_ = 0;

      public function __construct(\TProtocol $input, /*?\TProtocol*/ $output=null) {
        $this->input_ = $input;
        $this->output_ = $output ? $output : $input;
        $this->eventHandler_ = new \TClientEventHandler();
      }

      public function setEventHandler(\TClientEventHandler $event_handler) {
        $this->eventHandler_ = $event_handler;
      }

      public function getEventHandler() {
        return $this->eventHandler_;
      }

      private function getsequenceid() {
        $currentseqid = $this->seqid_;
        if ($this->seqid_ >= 0x7fffffff) {
           $this->seqid_ = 0;
        } else {
           $this->seqid_++;
        }
        return $currentseqid;
      }

      /**
       * Original thrift definition:-
       * TestResult
       *   testFunction(1: FunctionToTest functionToTest,
       *                2: TestDataOverride testDataOverride)
       *   throws (1: ValidationException validationException,
       *           2: AuthorizationException authorizationException,
       *           3: InternalSystemException internalSystemException);
       */
      public function testFunction($functionToTest, $testDataOverride)
      {
        $currentseqid = $this->send_testFunction($functionToTest, $testDataOverride);
        return $this->recv_testFunction($currentseqid);
      }

      public function send_testFunction($functionToTest, $testDataOverride)
      {
        $currentseqid = $this->getsequenceid();
        $args = new SupplierApiTest_testFunction_args();
        $args->functionToTest = $functionToTest;
        $args->testDataOverride = $testDataOverride;
        try {
          $this->eventHandler_->preSend('testFunction', $args, $currentseqid);
          $bin_accel = ($this->output_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
          $compact_accel = ($this->output_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
          if ($bin_accel)
          {
            thrift_protocol_write_binary($this->output_, 'testFunction', \TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
          }
          else if ($compact_accel)
          {
            thrift_protocol_write_compact($this->output_, 'testFunction', \TMessageType::CALL, $args, $currentseqid, false);
          }
          else
          {
            $this->output_->writeMessageBegin('testFunction', \TMessageType::CALL, $currentseqid);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
          }
        } catch (\THandlerShortCircuitException $ex) {
          switch ($ex->resultType) {
            case \THandlerShortCircuitException::R_EXPECTED_EX:
            case \THandlerShortCircuitException::R_UNEXPECTED_EX:
              $this->eventHandler_->sendError('testFunction', $args, $currentseqid, $ex->result);
              throw $ex->result;
            case \THandlerShortCircuitException::R_SUCCESS:
            default:
              $this->eventHandler_->postSend('testFunction', $args, $currentseqid);
              return $currentseqid;
          }
        } catch (\Exception $ex) {
          $this->eventHandler_->sendError('testFunction', $args, $currentseqid, $ex);
          throw $ex;
        }
        $this->eventHandler_->postSend('testFunction', $args, $currentseqid);
        return $currentseqid;
      }

      public function recv_testFunction($expectedsequenceid = null)
      {
        try {
          $this->eventHandler_->preRecv('testFunction', $expectedsequenceid);
          $bin_accel = ($this->input_ instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
          $compact_accel = ($this->input_ instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact') && \TCompactProtocolAccelerated::checkVersion(1);
          if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'SupplierApiTest_testFunction_result', $this->input_->isStrictRead());
          else if ($compact_accel) $result = thrift_protocol_read_compact($this->input_, 'SupplierApiTest_testFunction_result');
          else
          {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == \TMessageType::EXCEPTION) {
              $x = new \TApplicationException();
              $x->read($this->input_);
              $this->input_->readMessageEnd();
              throw $x;
            }
            $result = new SupplierApiTest_testFunction_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
            if (isset($expectedsequenceid) && ($rseqid != $expectedsequenceid)) {
              throw new \TProtocolException("testFunction failed: sequence id is out of order");
            }
          }
        } catch (\THandlerShortCircuitException $ex) {
          switch ($ex->resultType) {
            case \THandlerShortCircuitException::R_EXPECTED_EX:
              $this->eventHandler_->recvException('testFunction', $expectedsequenceid, $ex->result);
              throw $ex->result;
            case \THandlerShortCircuitException::R_UNEXPECTED_EX:
              $this->eventHandler_->recvError('testFunction', $expectedsequenceid, $ex->result);
              throw $ex->result;
            case \THandlerShortCircuitException::R_SUCCESS:
            default:
              $this->eventHandler_->postRecv('testFunction', $expectedsequenceid, $ex->result);
              return $ex->result;
          }
        } catch (\Exception $ex) {
          $this->eventHandler_->recvError('testFunction', $expectedsequenceid, $ex);
          throw $ex;
        }
        if ($result->success !== null) {
          $this->eventHandler_->postRecv('testFunction', $expectedsequenceid, $result->success);
          return $result->success;
        }
        if ($result->validationException !== null) {
          $this->eventHandler_->recvException('testFunction', $expectedsequenceid, $result->validationException);
          throw $result->validationException;
        }
        if ($result->authorizationException !== null) {
          $this->eventHandler_->recvException('testFunction', $expectedsequenceid, $result->authorizationException);
          throw $result->authorizationException;
        }
        if ($result->internalSystemException !== null) {
          $this->eventHandler_->recvException('testFunction', $expectedsequenceid, $result->internalSystemException);
          throw $result->internalSystemException;
        }
        $x = new \TApplicationException("testFunction failed: unknown result", \TApplicationException::MISSING_RESULT);
        $this->eventHandler_->recvError('testFunction', $expectedsequenceid, $x);
        throw $x;
      }

}

class SupplierApiTestProcessor implements \IThriftProcessor {
      protected $handler_ = null;
      protected $eventHandler_ = null;
      protected $exceptionHandler_ = null;
      public function __construct(SupplierApiTestIf $handler) {
        $this->handler_ = $handler;
        $this->eventHandler_ = new \TProcessorEventHandler();
      }

      public function setEventHandler(\TProcessorEventHandler $event_handler) {
        $this->eventHandler_ = $event_handler;
      }

      public function getEventHandler() {
        return $this->eventHandler_;
      }

      public function setExceptionHandler(\IProcessorExceptionHandler $exception_handler) {
        $this->exceptionHandler_ = $exception_handler;
      }

      public function getExceptionHandler() {
        return $this->exceptionHandler_;
      }

      public function process(\TProtocol $input, \TProtocol $output) {
        $rseqid = 0;
        $fname = null;
        $mtype = 0;

        $input->readMessageBegin($fname, $mtype, $rseqid);
        $methodname = 'process_'.$fname;
        if (!method_exists($this, $methodname)) {
          $handler_ctx = $this->eventHandler_->getHandlerContext($methodname);
          $this->eventHandler_->preRead($handler_ctx, $methodname, array());
          $input->skip(\TType::STRUCT);
          $input->readMessageEnd();
          $this->eventHandler_->postRead($handler_ctx, $methodname, array());
          $x = new \TApplicationException('Function '.$fname.' not implemented.', \TApplicationException::UNKNOWN_METHOD);
          $this->eventHandler_->handlerError($handler_ctx, $methodname, $x);
          $output->writeMessageBegin($fname, \TMessageType::EXCEPTION, $rseqid);
          $x->write($output);
          $output->writeMessageEnd();
          $output->getTransport()->flush();
          return;
        }
        $this->$methodname($rseqid, $input, $output);
        return true;
      }

      protected function process_testFunction($seqid, \TProtocol $input, \TProtocol $output) {
        $handler_ctx = $this->eventHandler_->getHandlerContext('testFunction');
        $reply_type = \TMessageType::REPLY;

        $this->eventHandler_->preRead($handler_ctx, 'testFunction', array());

        $bin_accel = ($input instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary_struct');
        $compact_accel = ($input instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_compact_struct') && \TCompactProtocolAccelerated::checkVersion(1);

        if ($bin_accel) $args = thrift_protocol_read_binary_struct($input, 'SupplierApiTest_testFunction_args');
        else if ($compact_accel) $args = thrift_protocol_read_compact_struct($input, 'SupplierApiTest_testFunction_args');
        else {
          $args = new SupplierApiTest_testFunction_args();
          $args->read($input);
        }
        $input->readMessageEnd();
        $this->eventHandler_->postRead($handler_ctx, 'testFunction', $args);
        $result = new SupplierApiTest_testFunction_result();
        try {
          $this->eventHandler_->preExec($handler_ctx, 'testFunction', $args);
          try {
            $result->success = $this->handler_->testFunction($args->functionToTest, $args->testDataOverride);
          } catch (\Exception $e) {
            if ($this->exceptionHandler_ === null) {
              throw  $e;
            } else {
              $this->exceptionHandler_->handle('testFunction', $e);
            }
          }
          $this->eventHandler_->postExec($handler_ctx, 'testFunction', $result);
        } catch (ValidationException $exc0) {
          $this->eventHandler_->handlerException($handler_ctx, 'testFunction', $exc0);
          $result->validationException = $exc0;
        } catch (AuthorizationException $exc1) {
          $this->eventHandler_->handlerException($handler_ctx, 'testFunction', $exc1);
          $result->authorizationException = $exc1;
        } catch (InternalSystemException $exc2) {
          $this->eventHandler_->handlerException($handler_ctx, 'testFunction', $exc2);
          $result->internalSystemException = $exc2;
        } catch (\Exception $ex) {
          $reply_type = \TMessageType::EXCEPTION;
          $this->eventHandler_->handlerError($handler_ctx, 'testFunction', $ex);
          $result = new \TApplicationException($ex->getMessage());
        }
        $bin_accel = ($output instanceof \TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
        $compact_accel = ($output instanceof \TProtocol::$TCOMPACTPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_compact') && \TCompactProtocolAccelerated::checkVersion(1);
        $this->eventHandler_->preWrite($handler_ctx, 'testFunction', $result);
        if ($bin_accel)
        {
          thrift_protocol_write_binary($output, 'testFunction', $reply_type, $result, $seqid, $output->isStrictWrite());
        }
        else if ($compact_accel)
        {
          thrift_protocol_write_compact($output, 'testFunction', $reply_type, $result, $seqid);
        }
        else
        {
          $output->writeMessageBegin("testFunction", $reply_type, $seqid);
          $result->write($output);
          $output->writeMessageEnd();
          $output->getTransport()->flush();
        }
        $this->eventHandler_->postWrite($handler_ctx, 'testFunction', $result);
      }
}
// HELPER FUNCTIONS AND STRUCTURES

class SupplierApiTest_testFunction_args implements \IThriftStruct {
        static $_TSPEC = array(
          1 => array(
            'var' => 'functionToTest',
            'type' => \TType::I32,
            'enum' => 'FunctionToTest',
            ),
          2 => array(
            'var' => 'testDataOverride',
            'type' => \TType::STRUCT,
            'class' => 'TestDataOverride',
            ),
          );
        public static $_TFIELDMAP = array(
          'functionToTest' => 1,
          'testDataOverride' => 2,
        );
        const STRUCTURAL_ID = 8546643100747365087;
        public $functionToTest = null;
        public $testDataOverride = null;

        public function __construct($vals=null) {
          if (is_array($vals)) {
            if (isset($vals['functionToTest'])) {
              $this->functionToTest = $vals['functionToTest'];
            }
            if (isset($vals['testDataOverride'])) {
              $this->testDataOverride = $vals['testDataOverride'];
            }
          } else if ($vals) {
            throw new \TProtocolException(
              'SupplierApiTest_testFunction_args constructor must be passed array or null'
            );
          }
        }

        public function getName() {
          return 'SupplierApiTest_testFunction_args';
        }

        public static function __set_state($vals) {
          return new SupplierApiTest_testFunction_args($vals);
        }

        public function read(\TProtocol $input)
        {
          $xfer = 0;
          $fname = null;
          $ftype = 0;
          $fid = 0;
          $xfer += $input->readStructBegin($fname);
          while (true)
          {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == \TType::STOP) {
              break;
            }
            if (!$fid && $fname !== null) {
              if (isset(self::$_TFIELDMAP[$fname])) {
                $fid = self::$_TFIELDMAP[$fname];
                $ftype = self::$_TSPEC[$fid]['type'];
              }
            }
            switch ($fid)
            {
              case 1:
                if ($ftype == \TType::I32) {
                  $xfer += $input->readI32($this->functionToTest);
                } else {
                  $xfer += $input->skip($ftype);
                }
                break;
              case 2:
                if ($ftype == \TType::STRUCT) {
                  $this->testDataOverride = new TestDataOverride();
                  $xfer += $this->testDataOverride->read($input);
                } else {
                  $xfer += $input->skip($ftype);
                }
                break;
              default:
                $xfer += $input->skip($ftype);
                break;
            }
            $xfer += $input->readFieldEnd();
          }
          $xfer += $input->readStructEnd();
          return $xfer;
        }

        public function write(\TProtocol $output) {
          $xfer = 0;
          $xfer += $output->writeStructBegin('SupplierApiTest_testFunction_args');
          if ($this->functionToTest !== null) {
            $xfer += $output->writeFieldBegin('functionToTest', \TType::I32, 1);
            $xfer += $output->writeI32($this->functionToTest);
            $xfer += $output->writeFieldEnd();
          }
          if ($this->testDataOverride !== null) {
            if (!is_object($this->testDataOverride)) {
              throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('testDataOverride', \TType::STRUCT, 2);
            $xfer += $this->testDataOverride->write($output);
            $xfer += $output->writeFieldEnd();
          }
          $xfer += $output->writeFieldStop();
          $xfer += $output->writeStructEnd();
          return $xfer;
        }

      }

class SupplierApiTest_testFunction_result implements \IThriftStruct {
        static $_TSPEC = array(
          0 => array(
            'var' => 'success',
            'type' => \TType::STRUCT,
            'class' => 'TestResult',
            ),
          1 => array(
            'var' => 'validationException',
            'type' => \TType::STRUCT,
            'class' => 'ValidationException',
            ),
          2 => array(
            'var' => 'authorizationException',
            'type' => \TType::STRUCT,
            'class' => 'AuthorizationException',
            ),
          3 => array(
            'var' => 'internalSystemException',
            'type' => \TType::STRUCT,
            'class' => 'InternalSystemException',
            ),
          );
        public static $_TFIELDMAP = array(
          'success' => 0,
          'validationException' => 1,
          'authorizationException' => 2,
          'internalSystemException' => 3,
        );
        const STRUCTURAL_ID = 4956297884206353194;
        public $success = null;
        public $validationException = null;
        public $authorizationException = null;
        public $internalSystemException = null;

        public function __construct($vals=null) {
          if (is_array($vals)) {
            if (isset($vals['success'])) {
              $this->success = $vals['success'];
            }
            if (isset($vals['validationException'])) {
              $this->validationException = $vals['validationException'];
            }
            if (isset($vals['authorizationException'])) {
              $this->authorizationException = $vals['authorizationException'];
            }
            if (isset($vals['internalSystemException'])) {
              $this->internalSystemException = $vals['internalSystemException'];
            }
          } else if ($vals) {
            throw new \TProtocolException(
              'SupplierApiTest_testFunction_result constructor must be passed array or null'
            );
          }
        }

        public function getName() {
          return 'SupplierApiTest_testFunction_result';
        }

        public static function __set_state($vals) {
          return new SupplierApiTest_testFunction_result($vals);
        }

        public function read(\TProtocol $input)
        {
          $xfer = 0;
          $fname = null;
          $ftype = 0;
          $fid = 0;
          $xfer += $input->readStructBegin($fname);
          while (true)
          {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == \TType::STOP) {
              break;
            }
            if (!$fid && $fname !== null) {
              if (isset(self::$_TFIELDMAP[$fname])) {
                $fid = self::$_TFIELDMAP[$fname];
                $ftype = self::$_TSPEC[$fid]['type'];
              }
            }
            switch ($fid)
            {
              case 0:
                if ($ftype == \TType::STRUCT) {
                  $this->success = new TestResult();
                  $xfer += $this->success->read($input);
                } else {
                  $xfer += $input->skip($ftype);
                }
                break;
              case 1:
                if ($ftype == \TType::STRUCT) {
                  $this->validationException = new ValidationException();
                  $xfer += $this->validationException->read($input);
                } else {
                  $xfer += $input->skip($ftype);
                }
                break;
              case 2:
                if ($ftype == \TType::STRUCT) {
                  $this->authorizationException = new AuthorizationException();
                  $xfer += $this->authorizationException->read($input);
                } else {
                  $xfer += $input->skip($ftype);
                }
                break;
              case 3:
                if ($ftype == \TType::STRUCT) {
                  $this->internalSystemException = new InternalSystemException();
                  $xfer += $this->internalSystemException->read($input);
                } else {
                  $xfer += $input->skip($ftype);
                }
                break;
              default:
                $xfer += $input->skip($ftype);
                break;
            }
            $xfer += $input->readFieldEnd();
          }
          $xfer += $input->readStructEnd();
          return $xfer;
        }

        public function write(\TProtocol $output) {
          $xfer = 0;
          $xfer += $output->writeStructBegin('SupplierApiTest_testFunction_result');
          if ($this->success !== null) {
            if (!is_object($this->success)) {
              throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('success', \TType::STRUCT, 0);
            $xfer += $this->success->write($output);
            $xfer += $output->writeFieldEnd();
          }
          if ($this->validationException !== null) {
            $xfer += $output->writeFieldBegin('validationException', \TType::STRUCT, 1);
            $xfer += $this->validationException->write($output);
            $xfer += $output->writeFieldEnd();
          }
          if ($this->authorizationException !== null) {
            $xfer += $output->writeFieldBegin('authorizationException', \TType::STRUCT, 2);
            $xfer += $this->authorizationException->write($output);
            $xfer += $output->writeFieldEnd();
          }
          if ($this->internalSystemException !== null) {
            $xfer += $output->writeFieldBegin('internalSystemException', \TType::STRUCT, 3);
            $xfer += $this->internalSystemException->write($output);
            $xfer += $output->writeFieldEnd();
          }
          $xfer += $output->writeFieldStop();
          $xfer += $output->writeStructEnd();
          return $xfer;
        }

      }

?>
